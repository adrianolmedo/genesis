package store

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/adrianolmedo/genesis"
	"github.com/adrianolmedo/genesis/pgsql"
	"github.com/adrianolmedo/genesis/pgsql/sqlc/dbgen"

	"github.com/jackc/pgx/v5"
	"github.com/pborman/uuid"
)

// ProductRepo manages the Product storage.
type ProductRepo struct {
	q *dbgen.Queries // methods generated by sqlc
}

// NewProductRepo creates a new Product repository instance.
// It initializes the dbgen.Queries with the provided database connection.
func NewProductRepo(db dbgen.DBTX) *ProductRepo {
	return &ProductRepo{
		q: dbgen.New(db),
	}
}

// Create add one product to the storage.
func (r *ProductRepo) Create(ctx context.Context, m *Product) error {
	m.UUID = genesis.NextUUID()
	m.CreatedAt = time.Now()

	id, err := r.q.ProductCreate(ctx, dbgen.ProductCreateParams{
		Uuid:         uuid.Parse(m.UUID),
		Name:         m.Name,
		Observations: m.Observations,
		Price:        m.Price,
		CreatedAt:    m.CreatedAt,
	})
	if err != nil {
		return err
	}

	m.ID = id
	return nil
}

func (r *ProductRepo) ByID(ctx context.Context, id int64) (*Product, error) {
	m, err := r.q.ProductByID(ctx, id)
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrProductNotFound
	}

	if err != nil {
		return nil, err
	}

	p := &Product{
		ID:           m.ID,
		UUID:         m.Uuid.String(),
		Name:         m.Name,
		Observations: m.Observations,
		Price:        m.Price,
	}

	p.CreatedAt = m.CreatedAt
	p.UpdatedAt = pgsql.NullTimeToPtr(m.UpdatedAt)
	p.DeletedAt = pgsql.NullTimeToPtr(m.DeletedAt)

	return p, nil
}

func (r *ProductRepo) Update(ctx context.Context, m Product) error {
	m.UpdatedAt = pgsql.TimeToPtr(time.Now())

	_, err := r.q.ProductUpdate(ctx, dbgen.ProductUpdateParams{
		ID:           m.ID,
		Name:         m.Name,
		Observations: m.Observations,
		Price:        m.Price,
		UpdatedAt:    pgsql.TimePtrToNull(m.UpdatedAt),
	})
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return ErrProductNotFound
	}

	if err != nil {
		return err
	}

	return nil
}

// All returns all products from the storage.
func (r *ProductRepo) All(ctx context.Context) (Products, error) {
	dbProducts, err := r.q.ProductAll(ctx)
	if err != nil {
		return nil, err
	}
	return toDomainProducts(dbProducts), nil
}

// toDomainProducts converts a slice of dbgen.Product to a slice of domain.Product.
func toDomainProducts(dbProducts []dbgen.Product) Products {
	products := make(Products, 0, len(dbProducts))
	for _, m := range dbProducts {
		p := Product{
			ID:           m.ID,
			UUID:         m.Uuid.String(),
			Name:         m.Name,
			Observations: m.Observations,
			Price:        m.Price,
		}

		p.CreatedAt = m.CreatedAt
		p.UpdatedAt = pgsql.NullTimeToPtr(m.UpdatedAt)
		p.DeletedAt = pgsql.NullTimeToPtr(m.DeletedAt)

		products = append(products, p)
	}
	return products
}

// Delete marks a product as deleted in the storage.
func (r *ProductRepo) Delete(ctx context.Context, id int64) error {
	_, err := r.q.ProductDelete(ctx, dbgen.ProductDeleteParams{
		ID:        id,
		DeletedAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return ErrProductNotFound
	}

	if err != nil {
		return err
	}

	return nil
}

// HardDelete deletes a product from the storage (permanently).
func (r *ProductRepo) HardDelete(ctx context.Context, id int64) error {
	_, err := r.q.ProductHardDelete(ctx, id)
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return ErrProductNotFound
	}

	if err != nil {
		return err
	}

	return nil
}

// DeleteAll deletes all products from the storage (permanently).
func (r *ProductRepo) DeleteAll(ctx context.Context) error {
	err := r.q.ProductDeleteAll(ctx)
	if err != nil {
		return fmt.Errorf("can't truncate table: %v", err)
	}
	return nil
}
