package sqlc

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	domain "github.com/adrianolmedo/genesis"
	"github.com/adrianolmedo/genesis/pgsql"
	"github.com/adrianolmedo/genesis/pgsql/sqlc/dbgen"

	"github.com/jackc/pgx/v5"
	"github.com/pborman/uuid"
)

// Product repository.
type Product struct {
	db dbgen.DBTX     // Query, QueryRow, Exec
	q  *dbgen.Queries // methods generated by sqlc
}

// NewProduct creates a new Product repository instance.
// It initializes the dbgen.Queries with the provided database connection.
func NewProduct(db dbgen.DBTX) *Product {
	return &Product{
		db: db,
		q:  dbgen.New(db),
	}
}

// Create add one product to the storage.
func (r Product) Create(m *domain.Product) error {
	m.UUID = domain.NextUUID()
	m.CreatedAt = time.Now()

	id, err := r.q.ProductCreate(context.Background(), dbgen.ProductCreateParams{
		Uuid:         uuid.Parse(m.UUID),
		Name:         m.Name,
		Observations: m.Observations,
		Price:        m.Price,
		CreatedAt:    m.CreatedAt,
	})
	if err != nil {
		return err
	}

	m.ID = id
	return nil
}

func (r Product) ByID(id int64) (*domain.Product, error) {
	m, err := r.q.ProductByID(context.Background(), id)
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return nil, domain.ErrProductNotFound
	}

	if err != nil {
		return nil, err
	}

	p := &domain.Product{
		ID:           m.ID,
		UUID:         m.Uuid.String(),
		Name:         m.Name,
		Observations: m.Observations,
		Price:        m.Price,
	}

	p.CreatedAt = m.CreatedAt
	p.UpdatedAt = pgsql.PtrFromNullTime(m.UpdatedAt)
	p.DeletedAt = pgsql.PtrFromNullTime(m.DeletedAt)

	return p, nil
}

func (r Product) Update(m domain.Product) error {
	m.UpdatedAt = pgsql.TimePtr(time.Now())

	_, err := r.q.ProductUpdate(context.Background(), dbgen.ProductUpdateParams{
		ID:           m.ID,
		Name:         m.Name,
		Observations: m.Observations,
		Price:        m.Price,
		UpdatedAt:    pgsql.NullTimeFromPtr(m.UpdatedAt),
	})
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return domain.ErrProductNotFound
	}

	if err != nil {
		return err
	}

	return nil
}

// All returns all products from the storage.
func (r Product) All() (domain.Products, error) {
	dbProducts, err := r.q.ProductAll(context.Background())
	if err != nil {
		return nil, err
	}
	return toDomainProducts(dbProducts), nil
}

// toDomainProducts converts a slice of dbgen.Product to a slice of domain.Product.
func toDomainProducts(dbProducts []dbgen.Product) domain.Products {
	products := make(domain.Products, 0, len(dbProducts))
	for _, m := range dbProducts {
		p := &domain.Product{
			ID:           m.ID,
			UUID:         m.Uuid.String(),
			Name:         m.Name,
			Observations: m.Observations,
			Price:        m.Price,
		}

		p.CreatedAt = m.CreatedAt
		p.UpdatedAt = pgsql.PtrFromNullTime(m.UpdatedAt)
		p.DeletedAt = pgsql.PtrFromNullTime(m.DeletedAt)

		products = append(products, p)
	}
	return products
}

// Delete marks a product as deleted in the storage.
func (r Product) Delete(id int64) error {
	_, err := r.q.ProductDelete(context.Background(), dbgen.ProductDeleteParams{
		ID:        id,
		DeletedAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return domain.ErrProductNotFound
	}

	if err != nil {
		return err
	}

	return nil
}

// HardDelete deletes a product from the storage (permanently).
func (r Product) HardDelete(id int64) error {
	_, err := r.q.ProductHardDelete(context.Background(), id)
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return domain.ErrProductNotFound
	}

	if err != nil {
		return err
	}

	return nil
}

// DeleteAll deletes all products from the storage (permanently).
func (r Product) DeleteAll() error {
	err := r.q.ProductDeleteAll(context.Background())
	if err != nil {
		return fmt.Errorf("can't truncate table: %v", err)
	}
	return nil
}
