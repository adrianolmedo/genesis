package sqlc

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	domain "github.com/adrianolmedo/genesis"
	"github.com/adrianolmedo/genesis/pgsql"
	"github.com/adrianolmedo/genesis/pgsql/sqlc/dbgen"

	"github.com/jackc/pgx/v5"
	"github.com/pborman/uuid"
)

// User repository.
type User struct {
	db dbgen.DBTX     // Query, QueryRow, Exec
	q  *dbgen.Queries // methods generated by sqlc
}

// NewUser creates a new User repository instance.
// It initializes the dbgen.Queries with the provided database connection.
func NewUser(conn dbgen.DBTX) *User {
	return &User{
		q:  dbgen.New(conn),
		db: conn,
	}
}

// Create a User to the storage.
// It sets the UUID and CreatedAt fields of the User model before inserting
// it into the database.
func (r User) Create(m *domain.User) error {
	m.UUID = domain.NextUUID()
	m.CreatedAt = time.Now()

	id, err := r.q.UserCreate(context.Background(), dbgen.UserCreateParams{
		Uuid:      uuid.Parse(m.UUID),
		FirstName: m.FirstName,
		LastName:  m.LastName,
		Email:     m.Email,
		Password:  m.Password,
		CreatedAt: m.CreatedAt,
	})

	if err != nil {
		return err
	}

	m.ID = id
	return nil
}

// ByLogin get a User from its login data.
func (r User) ByLogin(email, pass string) error {
	id, err := r.q.UserByLogin(context.Background(), dbgen.UserByLoginParams{
		Email:    email,
		Password: pass,
	})
	if err != nil {
		return err
	}

	if id == 0 {
		return domain.ErrUserNotFound
	}

	return nil
}

// ByID get a User from its id.
func (r User) ByID(id int64) (*domain.User, error) {
	m, err := r.q.UserByID(context.Background(), id)
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return nil, domain.ErrUserNotFound
	}

	if err != nil {
		return nil, err
	}

	u := &domain.User{
		ID:        m.ID,
		UUID:      m.Uuid.String(),
		FirstName: m.FirstName,
		LastName:  m.LastName,
		Email:     m.Email,
		Password:  m.Password,
	}

	u.CreatedAt = m.CreatedAt
	u.UpdatedAt = pgsql.PtrFromNullTime(m.UpdatedAt)
	u.DeletedAt = pgsql.PtrFromNullTime(m.DeletedAt)

	return u, nil
}

// Update updates a user in the database.
func (r User) Update(m domain.User) error {
	m.UpdatedAt = pgsql.TimePtr(time.Now())

	_, err := r.q.UserUpdate(context.Background(), dbgen.UserUpdateParams{
		ID:        m.ID,
		FirstName: m.FirstName,
		LastName:  m.LastName,
		Email:     m.Email,
		Password:  m.Password,
		UpdatedAt: pgsql.NullTimeFromPtr(m.UpdatedAt),
	})
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return domain.ErrUserNotFound
	}

	if err != nil {
		return err
	}

	return nil
}

// List returns a paginated list of users.
// It returns a pgsql.PagerResults containing the paginated users and total rows.
// If an error occurs during the query, it returns an empty PagerResults and the error.
func (r User) List(p *pgsql.Pager) (pgsql.PagerResults, error) {
	users, err := r.q.UserListAsc(context.Background(), dbgen.UserListAscParams{
		Sort:   p.Sort(),
		Offset: int32(p.Offset()),
		Limit:  int32(p.Limit()),
	})
	if err != nil {
		return pgsql.PagerResults{}, err
	}

	totalRows, err := r.q.UserListCount(context.Background())
	if err != nil {
		return pgsql.PagerResults{}, err
	}

	return p.Paginate(users, totalRows), nil
}

// All is like List but with custom SQL.
func (r User) All(p *pgsql.Pager) (pgsql.PagerResults, error) {
	query := `SELECT id, uuid, first_name, last_name, email, password, created_at, updated_at, deleted_at FROM "user" WHERE deleted_at IS NULL`
	query += " " + p.OrderBy()
	query += " " + p.LimitOffset()

	rows, err := r.db.Query(context.Background(), query)
	if err != nil {
		return pgsql.PagerResults{}, err
	}
	defer rows.Close()

	users := make(domain.Users, 0)

	for rows.Next() {
		var updatedAtNull, deletedAtNull sql.NullTime
		m := &domain.User{}

		err := rows.Scan(
			&m.ID,
			&m.UUID,
			&m.FirstName,
			&m.LastName,
			&m.CreatedAt,
			&updatedAtNull,
			&deletedAtNull,
		)
		if err != nil {
			return pgsql.PagerResults{}, err
		}

		m.UpdatedAt = pgsql.PtrFromNullTime(updatedAtNull)
		m.DeletedAt = pgsql.PtrFromNullTime(deletedAtNull)

		users = append(users, m)
	}

	if err := rows.Err(); err != nil {
		return pgsql.PagerResults{}, err
	}

	// Get total rows to calculate total pages.
	var totalRows int64
	err = r.db.QueryRow(context.Background(), `SELECT COUNT (*) FROM "user" WHERE deleted_at IS NULL`).Scan(&totalRows)
	if err != nil {
		return pgsql.PagerResults{}, err
	}

	return p.Paginate(users, totalRows), nil
}

// Delete marks a user as deleted in the storage.
// It sets the DeletedAt field to the current time, effectively
// soft-deleting the user.
func (r User) Delete(id int64) error {
	_, err := r.q.UserDelete(context.Background(), dbgen.UserDeleteParams{
		ID:        id,
		DeletedAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return domain.ErrUserNotFound
	}

	if err != nil {
		return err
	}
	return nil
}

// HardDelete deletes a user from the storage (permanently).
func (r User) HardDelete(id int64) error {
	_, err := r.q.UserHardDelete(context.Background(), id)
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return domain.ErrUserNotFound
	}

	if err != nil {
		return err
	}
	return nil
}

// DeleteAll deletes all users from the storage (permanently).
func (r User) DeleteAll() error {
	err := r.q.UserDeleteAll(context.Background())
	if err != nil {
		return fmt.Errorf("can't truncate table: %v", err)
	}
	return nil
}
