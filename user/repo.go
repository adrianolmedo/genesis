package user

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/adrianolmedo/genesis"
	"github.com/adrianolmedo/genesis/pgsql"
	"github.com/adrianolmedo/genesis/pgsql/sqlc/dbgen"

	"github.com/jackc/pgx/v5"
	"github.com/pborman/uuid"
)

// Repo manages the User storage.
type Repo struct {
	q *dbgen.Queries // methods generated by sqlc
}

// NewRepo creates a new User repository instance.
func NewRepo(db dbgen.DBTX) *Repo {
	return &Repo{
		q: dbgen.New(db),
	}
}

// Create a User to the storage.
// It sets the UUID and CreatedAt fields of the User model before inserting
// it into the database.
func (r *Repo) Create(ctx context.Context, m *User) error {
	m.UUID = genesis.NextUUID()
	m.CreatedAt = time.Now()
	id, err := r.q.UserCreate(ctx, dbgen.UserCreateParams{
		Uuid:      uuid.Parse(m.UUID),
		FirstName: m.FirstName,
		LastName:  m.LastName,
		Email:     m.Email,
		Password:  m.Password,
		CreatedAt: m.CreatedAt,
	})
	if err != nil {
		return err
	}
	m.ID = id
	return nil
}

// ByLogin get a User from its login data.
func (r *Repo) ByLogin(ctx context.Context, email, pass string) error {
	id, err := r.q.UserByLogin(ctx, dbgen.UserByLoginParams{
		Email:    email,
		Password: pass,
	})
	if err != nil {
		return err
	}
	if id == 0 {
		return ErrNotFound
	}
	return nil
}

// ByID get a User from its id.
func (r *Repo) ByID(ctx context.Context, id int64) (*User, error) {
	m, err := r.q.UserByID(ctx, id)
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrNotFound
	}
	if err != nil {
		return nil, err
	}
	u := &User{
		ID:        m.ID,
		UUID:      m.Uuid.String(),
		FirstName: m.FirstName,
		LastName:  m.LastName,
		Email:     m.Email,
		Password:  m.Password,
	}
	u.CreatedAt = m.CreatedAt
	u.UpdatedAt = pgsql.NullTimeToPtr(m.UpdatedAt)
	u.DeletedAt = pgsql.NullTimeToPtr(m.DeletedAt)
	return u, nil
}

// Update updates a user in the database.
func (r *Repo) Update(ctx context.Context, m User) error {
	m.UpdatedAt = pgsql.TimeToPtr(time.Now())
	_, err := r.q.UserUpdate(ctx, dbgen.UserUpdateParams{
		ID:        m.ID,
		FirstName: m.FirstName,
		LastName:  m.LastName,
		Email:     m.Email,
		Password:  m.Password,
		UpdatedAt: pgsql.TimePtrToNull(m.UpdatedAt),
	})
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return ErrNotFound
	}
	if err != nil {
		return err
	}
	return nil
}

// List returns a paginated list of users.
// It returns a pgsql.PagerResult containing the paginated users and total rows.
// If an error occurs during the query, it returns an empty PagerResult and the error.
func (r *Repo) List(ctx context.Context, p pgsql.Pager) (pgsql.PagerResult, error) {
	users, err := r.q.UserListAsc(ctx, dbgen.UserListAscParams{
		Sort:   p.Sort(),
		Offset: int32(p.Offset()),
		Limit:  int32(p.Limit()),
	})
	if err != nil {
		return pgsql.PagerResult{}, err
	}
	totalRows, err := r.q.UserListCount(ctx)
	if err != nil {
		return pgsql.PagerResult{}, err
	}
	return p.Paginate(users, totalRows), nil
}

// All is like List but with custom SQL.
/*func (r *Repo) All(ctx context.Context, p pgsql.Pager) (pgsql.PagerResult, error) {
	query := `SELECT id, uuid, first_name, last_name, email, password, created_at, updated_at, deleted_at FROM "user" WHERE deleted_at IS NULL`
	query += " " + p.OrderBy()
	query += " " + p.LimitOffset()

	rows, err := r.db.Query(ctx, query)
	if err != nil {
		return pgsql.PagerResult{}, err
	}
	defer rows.Close()

	users := make(domain.Users, 0)

	for rows.Next() {
		var updatedAtNull, deletedAtNull sql.NullTime
		m := &domain.User{}

		err := rows.Scan(
			&m.ID,
			&m.UUID,
			&m.FirstName,
			&m.LastName,
			&m.CreatedAt,
			&updatedAtNull,
			&deletedAtNull,
		)
		if err != nil {
			return pgsql.PagerResult{}, err
		}

		m.UpdatedAt = pgsql.PtrFromNullTime(updatedAtNull)
		m.DeletedAt = pgsql.PtrFromNullTime(deletedAtNull)

		users = append(users, m)
	}

	if err := rows.Err(); err != nil {
		return pgsql.PagerResult{}, err
	}

	// Get total rows to calculate total pages.
	var totalRows int64
	err = r.db.QueryRow(ctx, `SELECT COUNT (*) FROM "user" WHERE deleted_at IS NULL`).Scan(&totalRows)
	if err != nil {
		return pgsql.PagerResult{}, err
	}

	return p.Paginate(users, totalRows), nil
}*/

// Delete marks a user as deleted in the storage.
// It sets the DeletedAt field to the current time, effectively
// soft-deleting the user.
func (r *Repo) Delete(ctx context.Context, id int64) error {
	_, err := r.q.UserDelete(ctx, dbgen.UserDeleteParams{
		ID:        id,
		DeletedAt: sql.NullTime{Time: time.Now(), Valid: true},
	})
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return ErrNotFound
	}
	if err != nil {
		return err
	}
	return nil
}

// HardDelete deletes a user from the storage (permanently).
func (r *Repo) HardDelete(ctx context.Context, id int64) error {
	_, err := r.q.UserHardDelete(ctx, id)
	if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
		return ErrNotFound
	}

	if err != nil {
		return err
	}
	return nil
}

// DeleteAll deletes all users from the storage (permanently).
func (r *Repo) DeleteAll(ctx context.Context) error {
	err := r.q.UserDeleteAll(ctx)
	if err != nil {
		return fmt.Errorf("can't truncate table: %v", err)
	}
	return nil
}
